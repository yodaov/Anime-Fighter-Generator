<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Procedural Anime Fighter Generator</title>
  <style>
    :root { --fg: #f8f8f8; --bg:#000; --muted:#9aa0a6; --accent:#fff; }
    html, body { height: 100%; }
    body {
      margin: 0; background: var(--bg); color: var(--fg);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      display: grid; place-items: center;
    }
    .wrap { width: min(920px, 92vw); text-align: center; }
    h1 { font-size: 1.1rem; font-weight: 600; color: var(--muted); letter-spacing: .08em; text-transform: uppercase; margin: 0 0 1rem; }
    .screen { background: #000; border: 1px solid #222; border-radius: 16px; padding: 28px 22px; min-height: 62vh; width: 100%; max-width: 1200px; display: flex; flex-direction: column; gap: 18px; }
    .rows { flex: 1; display: flex; flex-direction: column; align-items: center; gap: 12px; justify-content: center; }
    .row { font-size: clamp(14px, 2.8vw, 32px); line-height: 1.15; letter-spacing: .02em; }
    .muted { color: var(--muted); font-size: .9em; }
    .controls { display: flex; gap: 12px; justify-content: center; flex-wrap: wrap; }
    button { cursor: pointer; font: inherit; color: #000; background: var(--accent); border: none; padding: 12px 18px; border-radius: 999px; font-weight: 700; letter-spacing: .04em; }
    button[disabled] { opacity: .5; cursor: not-allowed; }
    .hint { color: var(--muted); font-size: .85rem; margin-top: 6px; }
    .footer { color: var(--muted); font-size: .8rem; margin-top: 10px; }
    .slotting { opacity: .9; filter: blur(.4px); }
    .final { animation: pop .22s ease-out both; }
    @keyframes pop { from { transform: scale(.98); opacity: .6; } to { transform: scale(1); opacity: 1; } }
    .tiny { font-size: .9rem; }
    a { color: var(--fg); }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Procedural Anime Fighter Generator</h1>
    <div class="screen" role="region" aria-live="polite">
      <div class="rows" id="rows">
        <div class="muted tiny">Black screen ready. Press <b>Start</b> or hit <kbd>S</kbd>.</div>
      </div>
      <div class="controls">
        <button id="startBtn" autofocus>Start</button>
        <button id="rerollBtn" disabled>Reroll</button>
        <button id="copyBtn" disabled>Copy result</button>
      </div>
      <div class="hint" id="hint">Lists will be loaded from <code>RouletteLists.txt</code> in this folder.</div>
      <div class="footer">Made for GitHub Pages — single file, no build tools.</div>
    </div>
  </div>

  <!-- Data loader: expects RouletteLists.txt in the same directory. -->
  <script>
    // Utility: cryptographically-strong random int in [0, n)
    function randInt(n){ const a=new Uint32Array(1); self.crypto.getRandomValues(a); return a[0] % n; }

    // Parse the uploaded text file into category arrays.
    async function loadLists() {
      const hintEl = document.getElementById('hint');
      try {
        const res = await fetch('RouletteLists.txt', {cache: 'no-store'});
        if(!res.ok) throw new Error('HTTP '+res.status);
        const txt = await res.text();
        // Normalize line endings
        const lines = txt.replace(/\r\n?/g, '\n').split('\n');
        const sections = {};
        let current = null;
        for (let i=0; i<lines.length; i++) {
          const line = lines[i].trim();
          if (!line) continue; // keep duplicates probability by not deduping later
          // Heading detection: e.g., "First names:" or "All powers:" etc.
          const m = line.match(/^([A-Za-zÀ-ÿ()'\- ]+):\s*$/);
          if (m) { current = m[1].toLowerCase(); if(!sections[current]) sections[current]=[]; continue; }
          if (current) sections[current].push(line);
        }

        // Map our expected keys
        const firstNames = sections['first names'] || [];
        const surnames   = sections['surnames'] || [];
        const races      = sections['races'] || [];
        const mentality  = sections['mentality'] || [];
        const backgrounds= sections['backgrounds'] || [];
        const powerAmt   = (sections['power amount'] || []).filter(s=>/power/i.test(s));
        const powers     = sections['all powers'] || [];
        const weaknesses = sections['weaknesses'] || [];

        // Validate minimal viability
        const ok = [firstNames, surnames, races, mentality, backgrounds, powerAmt, powers, weaknesses].every(arr => arr.length>0);
        if(!ok) throw new Error('Could not locate one or more sections. Check headings and file placement.');

        hintEl.textContent = 'Lists loaded. Press Start!';
        return { firstNames, surnames, races, mentality, backgrounds, powerAmt, powers, weaknesses };
      } catch (err) {
        hintEl.innerHTML = 'Failed to load <code>RouletteLists.txt</code>: ' + err.message + '. Place it alongside this file and ensure headings end with a colon (:).';
        throw err;
      }
    }

    // Slot-machine effect for a single value
    function rollOne(list, durationMs=1800) {
      durationMs = durationMs * 1.6; // slower roll speed
      return new Promise(resolve => {
        const row = document.createElement('div');
        row.className = 'row slotting';
        row.textContent = '…';
        document.getElementById('rows').appendChild(row);

        let t0 = performance.now();
        let tick = 0;
        const easeOut = x => 1 - Math.pow(1-x, 3);
        function frame(now) {
          tick++;
          const elapsed = now - t0;
          const p = Math.min(1, elapsed / durationMs);
          // update fast at first, then slow towards the end
          if (tick % Math.max(1, Math.floor(8*easeOut(p))) === 0) {
            row.textContent = list[randInt(list.length)];
          }
          if (p < 1) requestAnimationFrame(frame); else {
            row.classList.remove('slotting');
            row.classList.add('final');
            resolve(row.textContent);
          }
        }
        requestAnimationFrame(frame);
      });
    }

    function clearRows(){ const rows=document.getElementById('rows'); rows.innerHTML=''; }

    function resultAsText() {
      return Array.from(document.querySelectorAll('#rows .row')).map(el=>el.textContent).join('\n');
    }

    (function main(){
      const startBtn = document.getElementById('startBtn');
      const rerollBtn = document.getElementById('rerollBtn');
      const copyBtn = document.getElementById('copyBtn');

      let listsCache = null;

      async function ensureLists(){
        if (listsCache) return listsCache; else return (listsCache = await loadLists());
      }

      async function run(){
        startBtn.disabled = true; rerollBtn.disabled = true; copyBtn.disabled = true;
        clearRows();
        const { firstNames, surnames, races, mentality, backgrounds, powerAmt, powers, weaknesses } = await ensureLists();

        // Order:
        // First name, Surname, Race, Mentality, Background, Power Amount, Power(s), Weakness
        const sequence = [
          () => rollOne(firstNames, 1600 + randInt(700)),
          () => rollOne(surnames,   1600 + randInt(700)),
          () => rollOne(races,      1700 + randInt(700)),
          () => rollOne(mentality,  1800 + randInt(700)),
          () => rollOne(backgrounds,1900 + randInt(800)),
          () => rollOne(powerAmt,   2000 + randInt(900)),
        ];

        const picked = [];
        for (const step of sequence) picked.push(await step());

        // Determine number of powers from the exact string
        const amtStr = picked[picked.length-1].toLowerCase();
        const nPowers = /2\s*powers/.test(amtStr) ? 2 : 1;

        const chosenPowers = new Set();
        for (let i=0; i<nPowers; i++) {
          let val;
          // Ensure distinct power if possible
          if (powers.length > 1) {
            do { val = powers[randInt(powers.length)]; } while(chosenPowers.has(val));
          } else { val = powers[0]; }
          chosenPowers.add(await rollOne([ ...chosenPowers.has(val) ? [] : [val], ...powers ], 1700 + randInt(700))); // quick animation reveal
        }

        await rollOne(weaknesses, 1700 + randInt(800));

        rerollBtn.disabled = false; copyBtn.disabled = false; startBtn.disabled = false;
      }

      startBtn.addEventListener('click', run);
      rerollBtn.addEventListener('click', run);
      copyBtn.addEventListener('click', async () => {
        const text = resultAsText();
        try { await navigator.clipboard.writeText(text); copyBtn.textContent = 'Copied!'; setTimeout(()=>copyBtn.textContent='Copy result', 900); }
        catch { copyBtn.textContent = 'Copy failed'; setTimeout(()=>copyBtn.textContent='Copy result', 900); }
      });

      // keyboard shortcut
      window.addEventListener('keydown', (e) => { if (e.key === 's' || e.key === 'S') startBtn.click(); });
    })();
  </script>
</body>
</html>
